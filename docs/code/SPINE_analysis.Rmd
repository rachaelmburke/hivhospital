---
title: "SPINE_analysis"
author: "Rachael Burke"
date: "2020/10/07"
output: html_document
---
  
RMD document for analysis for spine paper

## 0. Setup
Load the required libraries and data

```{r setup, message=FALSE, warning=FALSE}
## NB. one of these has "MASS" as a dependency, MASS also has 'select' as a function, so when you want normal 'select', need to specify dplyr::select
library(tidyverse)
library(lubridate)
library(knitr)
library(here)
library(janitor)
library(gt)
library(markdown)
library(ggtext)
library(naniar)
library(arsenal)
library(wesanderson)

library(rcompanion)
library(modelr)
library(vcd)
library(emmeans)
library(fitdistrplus)
library(splines)
library(rms)
library(stats)
library(Amelia)
library(mice)
library(boot)
library(broom)

load(here("data-raw", "spine.rda"))
spine <- spine
spine <- spine %>%
  dplyr::select(outcome,sex,quarter,ageg10,hiv,art) %>%  # this reduces dates to "quarter", may be better with dates as continuous?
  mutate(hiv=as.factor(hiv)) %>%
    mutate(hiv=fct_recode(hiv, "Negative" = "NON-REACTIVE",
                           "Positive" = "REACTIVE")) %>%
    mutate(art2 = case_when(art=="CONFIRMED DEFAULTER" ~ "no_art",
         art=="NO" ~ "no_art",
         art=="YES" ~ "yes_art")) %>%
  mutate(art2=if_else(is.na(hiv),"999",art2)) %>%
  mutate(art2=na_if(art2,"999")) %>% #need to revert to NA - I can't work out how to do this in one go!
  mutate(art=art2) %>%
  mutate(art=as.factor(art)) %>%
  dplyr::select(-art2)

# spine <- spine_summary %>%  # make summary data into tidy data
#   as_tibble() %>%
#   mutate(obs = map(n, ~rep_len(1, .x))) %>%
#   unnest(cols=c(obs)) %>%
#   dplyr::select(-n, -obs)

load(here("data", "cens_edit.rda"))
cens_edit <- cens_edit

# from https://gist.github.com/andrewheiss/a3134085e92c6607db39c5b14e1b879e (with some tweaks made)
 meld_predictions <- function(x) {
  x_melded <- mi.meld(matrix(x$.fitted), matrix(x$.se.fit)) #mi.meld from Amelia
  tibble(.fitted = as.numeric(x_melded$q.mi),
             .se.fit = as.numeric(x_melded$se.mi))
 }

# Date breaks for graphs 
breaks <- dmy(c("01-10-2012","01-01-2016","01-07-2019"))
breaks1 <- dmy(c("01-10-2012","01-01-2015","01-04-2017","01-07-2019"))
```

## 1. Table one

```{r tableone, results="asis"}
# What is the midpoint?
midpoint <- floor_date(median(cens_edit$quarter),"quarter")
a <- cens_edit %>% 
  filter(quarter==midpoint) %>% 
           uncount(pop) %>% 
           mutate(which="census") %>% 
           mutate(hiv=NA) %>%
  mutate(outcome=NA) %>%
  dplyr::select(-quarter,)

b <- spine %>% mutate(which="admissions") %>% dplyr::select(sex, ageg10,hiv, art, outcome,which) %>% mutate(outcome=as.factor(outcome))

c <- rbind(a,b)

# NB. The ART here N-miss isn't quite right, it includes all NAs for ART including those who are HIV negative / HIV unknown.
x <- tableby(which ~ ageg10 + sex + includeNA(hiv) + includeNA(outcome) + art, data=c, total=FALSE, test=FALSE)
summary(x)
```

## 2. Stacked barchart -- figure 1

```{r, warning=FALSE}
label_sum <- spine %>%
  group_by(ageg10, sex) %>%
  summarise(sum = sum(n()))

color <- c(wes_palettes$Zissou1[1],wes_palettes$Zissou1[4],wes_palettes$Zissou1[5])

spine %>% 
  mutate(hiv=as.character(hiv)) %>%
  mutate(hiv=replace_na(hiv,"Unknown")) %>%
  mutate(hiv=factor(hiv, levels=c("Unknown", "Negative","Positive"))) %>%
  mutate(q = group_indices(.,quarter)) %>%
  group_by(quarter) %>%
  mutate(number=n()) %>%
  ggplot() +
  geom_bar(aes(fill=hiv,x=quarter), position="fill") +
  geom_text(data=label_sum, aes(x=ymd("2014-10-01"), y=0.95, 
                label=paste0("n=",sum, sep=""))) +
  facet_grid(sex ~ageg10) + 
  scale_fill_manual(values=wes_palette("BottleRocket2")) +
    labs(
      #title="HIV status of adults admitted to QECH",
      #subtitle = "By quarter, and sex. n = total numer admissions between Q3.2012 to Q3.2019",
       x="Year and quarter",
       y="Proportion of admissions by HIV status",
       fill="HIV status") +
  scale_y_continuous() +
  scale_x_date(breaks=breaks1, date_labels = "%b %Y") +
  theme_bw() +
  theme(panel.spacing = unit(1, "lines"),
        axis.text.x=element_text(angle = 90))

ggsave(here("figures/fig_1.pdf"), width = 9, height = 6, dpi=300)
```

## 3. Run imputation

Notes:  This takes about ten minutes to run on my laptop.  The file with imputation already done is in data  folder, and loads at start of next chunk.  To check / run imputation take out # (set here to avoid having to run imputation to knit file each time), and be careful about what file is loaded at start of next chunk.

25 imputations run as 25% missingness for HIV status.
Assume HIV status MAR

* There were a very small number of people in dataset who have an ART status recorded but report HIV negative; I have set their ART status to NA.
* For everyone who had HIV status NA, but was imputed to be HIV positive, ART status is imputed as not on ART. This is because people who don't know their HIV status (a reasonable proportion of people with it missing) won't be on ART.  ART status in people who are "truly" HIV positive but NAs in dataset is MNAR, and difficult to know how to make assumptions.  This is a relatively small proportion of patients, and only relavent for part of the secondary objective.

``` {r impute, warning=FALSE}
pred_matrix <- make.predictorMatrix(spine) #this is default predictor matrix - all values help impute all other values (apart from itself)
pred_matrix[,6] <- 0 # changing the art column to 0 so that ART status not used to impute anything else 
pred_matrix[6,5] <- 0 # also asking HIV status not to be used to impute ART status, as I'm only going to try to impute art in those with HIV positive, so HIV status has no predictor value

# This is making a logical dataframe of what values should get imputed.  For most variables it's all NAs that get imputed, but for ART it's only those that are known HIV positive and NA
where <- spine %>%
  mutate(art=case_when(
    is.na(art)==FALSE ~ FALSE,
    is.na(art)==TRUE & hiv=="Positive" ~ TRUE,
    TRUE ~ FALSE
  )) %>%
  mutate(hiv=is.na(hiv)) %>%
  mutate(ageg10=is.na(ageg10)) %>%
  mutate(quarter=is.na(quarter)) %>%
  mutate(sex=is.na(sex)) %>%
  mutate(outcome=is.na(outcome))

# Then run the imputation --- this takes about 9 minutes to run -  have '#-ed' it by default to avoid running it by accident

######## IMPUTATION HERE!! ############
#################################3#####

# spine_mice <- mice(spine,m=25,maxit=5,seed=123,where=where,method="pmm",predictorMatrix=pred_matrix)

#usethis::use_data(spine_mice, overwrite = TRUE) 

####################################
###################################

``` 


Load imputed dataset, extract completed data from mids object, group by HIV status to get proportions / counts and merge with census data for population denomiator.

```{r, warning=FALSE}
load(here("data-raw", "spine_mice.rda"))  #NB. loads from data folder; can recreate using code above
#summary(spine_mice)

#get the imputed datasets in long format
spine_imp <- mice::complete(spine_mice, action="long", include = FALSE)  

# checking the number of HIV positive admissions in each imputation
x <- spine_imp %>% group_by(.imp) %>% filter(hiv=="Positive") %>% mutate(number=n()) %>% dplyr::select(.imp,number) %>% unique()
hist(x$number, main="Imputed number HIV+ admissions (25 imputations)")

#summarise the data sets by group to get the counts
spine_imp_gp <- spine_imp %>%
  group_by(.imp, quarter, ageg10, sex, hiv) %>% #NB. not interested in 'outcome' for this bit, so not grouped by this
  summarise(n_imputed=n())

# Create mean across all imputations
m <- spine_imp_gp %>% group_by(quarter, ageg10, sex, hiv) %>%
  summarise(n_imputed=mean(n_imputed)) %>%
  mutate(.imp=99)

spine_imp_gp2 <- spine_imp_gp %>% rbind(m)  # spine_imp_gp2 

#merge the denominators to the imputed grouped datasets
both_imp_gp <- left_join(spine_imp_gp, cens_edit) %>%
  mutate(n = case_when(is.na(n_imputed) ~ 0L,
                       TRUE ~ n_imputed)) %>%  # 'n' is now from n_imputed
  mutate(inc = (n/pop) * 100000) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter))

# usethis::use_data(both_imp_gp, overwrite = TRUE) # saving data

## Check imputed data (one of the imputations) by graphing original data and imputed 'observations'.
spine_imp2 <- mice::complete(spine_mice, action="long", include = TRUE)
spine_imp2$hiv_recorded <- cci(spine$hiv)  # cci = complete case indicator in mice
spine_imp3 <- spine_imp2 %>% filter(.imp==12) # take one of imputations


original_obs <- spine_imp3 %>%
  filter(hiv_recorded==TRUE) %>% # these are the ones with HIV wasn't missing
  group_by(quarter, ageg10, sex, hiv) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter))

original_obs %>%  
  mutate(HIV=as.character(hiv)) %>%
  mutate(HIV=replace_na(HIV,"Unknown / Missing")) %>%
  mutate(HIV=factor(HIV, levels=c("Unknown / Missing", "Negative","Positive"))) %>%
  ggplot() +
  geom_bar(aes(fill=HIV,x=quarter, y=n), stat="identity") +
  facet_grid(sex ~ageg10) + 
  scale_fill_manual(values=wes_palette("BottleRocket2",3)) +
    labs(
      title = "Original observations only (excl. NAs)",
       x="Year and quarter",
       y="Number of adult admissions",
      fill="HIV status") +
  scale_y_continuous() +
  scale_x_date(breaks=breaks1, date_labels = "%b%y ") +
  theme_bw() +
  theme(panel.spacing = unit(1, "lines"),
        axis.text.x=element_text(angle = 90))

imputed_obs <- spine_imp3 %>%
  filter(hiv_recorded==FALSE) %>% # these are the ones with HIV wasn't missing
  group_by(quarter, ageg10, sex, hiv) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter))

imputed_obs %>%  
  mutate(HIV=as.character(hiv)) %>%
  mutate(HIV=replace_na(HIV,"Unknown / Missing")) %>%
  mutate(HIV=factor(HIV, levels=c("Unknown / Missing", "Negative","Positive"))) %>%
  ggplot() +
  geom_bar(aes(fill=HIV,x=quarter, y=n), stat="identity") +
  facet_grid(sex ~ageg10) + 
  scale_fill_manual(values=wes_palette("BottleRocket2",3)) +
    labs(
      title = "Imputed observations only",
       x="Year and quarter",
       y="Number of adult admissions",
      fill="HIV status") +
  ylim(0,200) +
  scale_y_continuous() +
  scale_x_date(breaks=breaks1, date_labels = "%b%y ") +
  theme_bw() +
  theme(panel.spacing = unit(1, "lines"),
        axis.text.x=element_text(angle = 90))

# These two graphs looks fairly similar
```


## 4. Create the model for incidence of HIV positive neg binomial 3 splines

Creates 25 different models (one for each imputed data frame)

```{r inc_model, warning=FALSE}
#nest by imputed grouped dataset
by_imp <- both_imp_gp2 %>%
  ungroup() %>%
  nest_by(.imp)

# Fit the model for each imputed grouped dataset.  For HIV positive admissions.
model_imp_n3 <- by_imp %>% mutate(model = list(glm.nb(n ~ ns(q, knots = 3)*ageg10*sex, data = data %>% filter(hiv=="Positive"),offset(log(pop)))))

# Same model for HIV negative admissions
model_neg <- both_imp_gp2 %>% ungroup() %>% filter(hiv=="Negative") %>% nest_by(.imp) %>% mutate(model = list(glm.nb(n ~ ns(q, knots = 3)*ageg10*sex, data = data, offset(log(pop)))))

```

## 5. Get the predictions from the model 

Using Amelia mi.meld tools and Andrew Heiss' approach https://gist.github.com/andrewheiss/a3134085e92c6607db39c5b14e1b879e -- slightly modified

Build models seperately for incidence of both HIV positive and HIV negative admissions.

```{r, inc_graph, warning=F}

model2pred_imp <- function(df,m,var1,var2,var3,x){
  
  scaffold_df <- both_imp_gp2 %>%
    filter(hiv==x) %>% # HIV status
    ungroup() %>%
    dplyr::select(-.imp) %>%
    expand(q,ageg10,sex) 
  
  df2 <- df %>% filter(hiv==x)
  
  predict_melded <- tibble(models = m$model) %>%
    ungroup() %>%
    mutate(m = 1:n(),
         fitted = models %>% map(~ augment(., newdata = scaffold_df, se_fit=TRUE))) %>% # this gives fit from each model 
  unnest(fitted) %>%
  dplyr::select(m,q,ageg10,sex,.fitted,.se.fit) %>% # added in select to get rid of model df that was slowwing everything down....
  group_by(q,ageg10,sex) %>%  # Group by each of the variables that you vary
  nest(data= c(m, .fitted, .se.fit))  %>% # need to add 'm' here, otherwise nothing to meld over
  mutate(fitted_melded = data %>% map(~ meld_predictions(.))) %>%  #using the meld_predictions function I just defined
  unnest(fitted_melded) %>% 
    mutate(n_est = exp(.fitted)) %>%
    mutate(n_low =exp(.fitted - 1.96*.se.fit)) %>% #keep on response scale here
    mutate(n_high = exp(.fitted + 1.96*.se.fit))%>%
  left_join(df2) %>%
  mutate(inc=exp((.fitted - log(pop)) + log(100000))) %>% #incidence per 100,000
  mutate(inc_low=exp(((.fitted - 1.96*.se.fit) - log(pop)) + log(100000))) %>% 
  mutate(inc_high=exp(((.fitted + 1.96*.se.fit) - log(pop)) + log(100000))) %>%
    ungroup()
}

# Model predicted outputs
out_n3 <- model2pred_imp(both_imp_gp2,model_imp_n3,q,ageg10,sex,"Positive")  # so this has 25 imputed dataframes, but inc, n_est and their CIs are exactly the same now across all imputed data frames

out_neg <- model2pred_imp(both_imp_gp2,model_neg,q,ageg10,sex,"Negative")
```

## 6. Plot the predictions

Dots are from imputed dataset 12, model predictions are from melding across all dataframes.


```{r, warning=FALSE}
ggplot() +
  geom_line(data=out_n3, aes(x = quarter, y = inc, color=hiv)) +
  geom_ribbon(data=out_n3, aes(x=quarter, ymin = inc_low, ymax = inc_high, fill=hiv), alpha = 0.2) +
  geom_line(data=out_neg, aes(x = quarter, y = inc, color=hiv)) +
  geom_ribbon(data=out_neg, aes(x=quarter, ymin = inc_low, ymax = inc_high,fill=hiv), alpha = 0.2) +
  geom_point(data=both_imp_gp2 %>% filter(.imp==99) %>% filter(hiv=="Positive"), aes(x=quarter, y=((n_imputed/pop)*100000), color=hiv),size=0.1) +
  geom_point(data=both_imp_gp2 %>% filter(.imp==99) %>% filter(hiv=="Negative"), aes(x=quarter, y=((n_imputed/pop)*100000), color=hiv),size=0.1) +
  facet_grid(sex ~ ageg10) +
  scale_x_date(breaks=breaks1, date_labels = "%b%Y ") +
  scale_y_continuous(limits=c(0,500)) +
  scale_color_manual(values=c("Positive"="#0066FF","Negative" = "grey")) +
  scale_fill_manual(values=c("Positive"="#0066FF","Negative" = "grey")) +
  labs(
    title = "Incidence of hospital admission to QECH",
    subtitle="Quarterly population level incidence, by age, sex and HIV status",
    caption="Negative binomial model with three splines \n Points are mean of 25 imputed datasets, estimates melded across all imputed datasets using Rubin's rules",
    fill="HIV status",
    color="HIV status") +
  ylab("Incidence of admission per 100,000 population") +
  xlab("Year and quarter") +
    theme_bw() %+replace%
  theme(panel.spacing.x=unit(0.5, "cm"),
        axis.text.x=element_text(angle = 90))

ggsave(here("figures/fig_1.pdf"), width = 9, height = 6, dpi=300)

```

## 7. Determine the number of admissions "averted" and CI in imputed datasets

"Averted" = number fewer admissions than would have been if Q3.2012 incidence stayed same.  Note 'Averted' used as a shorthand verb, not assuming causation.

CI using parametric bootstrapping

Set up functions

```{r}
# Point estimate from 'real' data on the number of admissions averted (singling out .fitted on response scale, as in next change this is replaced by normal distribution to sample from)
avert_est <- function(df){
  df <- 
    {if (".imp" %in% names(df)==TRUE) df %>% filter(.imp==1) %>% dplyr::select(-.imp) else df} #NB. Each .imp contains exactly the same (melded) estimates of .fitted and .se.fitted (they remained nested in 25 dfs). This "if" bit is here so same function can be used in non-imputed dataframes.
    worst <- df %>% filter(quarter==dmy("01 Oct 2012")) %>%  
    mutate(q32012_inc = exp((
      .fitted
      - log(pop)))) %>%
    right_join(df) %>%
    group_by(ageg10,sex,hiv) %>% fill(q32012_inc) %>% ungroup() %>%
    mutate(worst_est= q32012_inc * pop) %>% 
    mutate(actual_est = exp(  #at the moment, this is redundant as already have exp(fitted) in df, but putting here for completeness when come to bootstrap estimate
    .fitted
    )) %>%
    mutate(avert_est = worst_est - actual_est)
}

avert_all_data <- function(df,lab){
  worst <- df %>% dplyr::select(worst_est) %>% sum()
  actual <- df%>% dplyr::select(actual_est) %>% sum()
  averted <- worst - actual
  averted_p <- averted/worst
  tribble(~"NA_handling", ~"worst", ~"actual", ~"averted",~"averted_p",
          lab, worst, actual, averted, averted_p)
}

# purr / pmap is from https://stackoverflow.com/questions/46207434/using-rnorm-for-a-dataframe 

# A bootstrap-able function, where .fitted is changed to a normal distribution with mean .fitted and st dev .se fitted.
# As must all be in one function to bootstrap, this combines 'avert_est' and 'avert_all_data'

avert_boot <- function(df){ # This creates estimates for each agegroup and sex category, sampling from normal distrubtion (on response scale) with mean = point estimate fitted model and sd = st error of fit, then exponentiated to link scale.
  df <- 
    {if (".imp" %in% names(df)==TRUE) df %>% filter(.imp==1) else df} #NB. Each .imp contains exactly the same (melded) estimates of .fitted and .se.fitted (they remained nested in 25 dfs)
  DF <- df %>% filter(quarter==dmy("01 Oct 2012")) %>%  
    mutate(q32012_inc = exp((
      as.numeric(pmap(list(.fitted,.se.fit), function(mu, sd) rnorm(1, mu, sd)))  # changed .fitted (point est of number admissions) to function of normal distrubctuion with mean .fitted and st dev se.fitted.  This should be bootstrapp-able.
      - log(pop)))) %>% # minus logs to determine population incidence
    right_join(df,by = c("q", "sex", "ageg10", ".fitted", ".se.fit", "n_est", "n_low", "n_high", "quarter", "pop", "n", "hiv", "inc", "inc_low", "inc_high")) %>%
    group_by(ageg10,sex,hiv) %>% fill(q32012_inc) %>% ungroup() %>%
    mutate(worst_est= q32012_inc * pop) %>%
    mutate(actual_est = exp(
      as.numeric(pmap(list(.fitted,.se.fit), function(mu, sd) rnorm(1, mu, sd)))
    )) %>%
    mutate(avert_est = worst_est - actual_est) %>%
    mutate(avert_p_est = avert_est / worst_est)
}

boot_fx <- function(df){
  df2 <- avert_boot(df)
  worst <- df2 %>% dplyr::select(worst_est) %>% sum()
  actual <- df2 %>% dplyr::select(actual_est) %>% sum()
  avert <- df2 %>% dplyr::select(avert_est) %>% sum()
  avert_p <- avert/worst
  c(worst, actual, avert,avert_p)
}

boot_fx_byageandsex <- function(df){
  df2 <- avert_boot(df) %>% dplyr::arrange(ageg10,sex) 
  group_vars <- df2 %>% group_by(ageg10,sex) %>%
    summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>%
    dplyr::select(ageg10,sex) 
  df2 %>% group_by(ageg10,sex) %>%
    summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>% ungroup() %>%
        mutate(avert_p=avert_est/worst_est) %>%
    dplyr::select(worst_est, actual_est, avert_est,avert_p) %>% as.matrix()
}

group_vars <- function(df){
  df2 <- avert_boot(df) %>% dplyr::arrange(ageg10,sex) 
  group_vars <- df2 %>% group_by(ageg10,sex) %>%
    summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>%
    dplyr::select(ageg10,sex)
  group_vars
  }
                                                                                        
```
Run for imputed dataset

``` {r}
# run function once to check - these should be fairly similar
avert_all_data(avert_est(out_n3),"imp") #df of output of point estimates
boot_fx(out_n3) # matrix of one boot rep of estimates

# now run function 1000 times and plot
boot_n3 <- boot(out_n3,boot_fx,R=1000,sim="parametric") #1000 iterations (takes about 90 secs to run)
sd_n3 <- c(sd(boot_n3$t[,1]),sd(boot_n3$t[,2]),sd(boot_n3$t[,3]),sd(boot_n3$t[,4])) # boot command output is a vector of estimate for worst / actual / averted; so boot output is a matrix.  Calculating st deviation for each column of matrix
sd_n3[[1]]

hist(boot_n3$t[,1]) # check histogram output
hist(boot_n3$t[,2])
hist(boot_n3$t[,3])
hist(boot_n3$t[,4])

## Make into a table
avert_table <- function(df,sd,lab) {
  avert_all_data(avert_est(df),lab) %>%
  mutate(worst.hi = worst + 1.96*(sd[[1]])) %>%
  mutate(worst.lo = worst - 1.96*(sd[[1]])) %>%
  mutate(actual.hi = actual + 1.96*(sd[[2]])) %>%
  mutate(actual.lo = actual - 1.96*(sd[[2]])) %>%
  mutate(avert.hi = averted + 1.96*(sd[[3]])) %>%
  mutate(avert.lo = averted - 1.96*(sd[[3]])) %>%
  mutate(avertp.hi = averted_p + 1.96*(sd[[4]])) %>%
  mutate(avertp.lo = averted_p - 1.96*(sd[[4]])) %>%
  mutate(worst_ = paste0(round(worst,digits=0)," (",round(worst.lo,digits=0)," to ",round(worst.hi, digits=0),")")) %>%
  mutate(actual_ = paste0(round(actual,digits=0)," (",round(actual.lo,digits=0)," to ",round(actual.hi, digits=0),")")) %>%
  mutate(averted_ = paste0(round(averted,digits=0)," (",round(avert.lo,digits=0)," to ",round(avert.hi, digits=0),")")) %>%
  mutate(avertedp_ = paste0(round(averted_p,digits=3)," (",round(avertp.lo,digits=3)," to ",round(avertp.hi, digits=3),")")) 
}
  
imp <- avert_table(out_n3,sd_n3,"imp")
```

## 8. Sensitivity analysis for estimates of admissions 'averted'  (Table 2 at the end of this)

Create grouped data and number admissions for various assumptions about HIV status (negative, positive, postitive_and_unknown, negative_and_unknown) from spine (individual) dataset and census.  

Then filter this dataset for desired sensitivity analyses

```{r}
# Construct grouped data from spine and census dataset

spine_gp_all_orig <- spine %>%  ## grouped, all admissions
  group_by(quarter,ageg10,sex) %>%
  summarise(n=n(), .groups="keep") %>%
  mutate(hiv="all") %>%
  ungroup()

spine_gp_hivpos_orig <- spine %>% # grouped, HIV pos
  filter(hiv=="Positive") %>%
  group_by(quarter,ageg10,sex) %>%
  summarise(n=n(), .groups="keep") %>%
  mutate(hiv="pos") %>%
  ungroup()

spine_gp_hivneg_orig <- spine %>% # grouped, HIV neg
  filter(hiv=="Negative") %>%
  group_by(quarter,ageg10,sex) %>%
  summarise(n=n(), .groups="keep") %>%
  mutate(hiv="neg") %>%
  ungroup()

spine_gp_hivunk_orig <- spine %>% # grouped, HIV unknown
  filter(is.na(hiv)) %>%
  group_by(quarter,ageg10,sex) %>%
  summarise(n=n(),.groups="keep") %>%
  mutate(hiv="unk") %>%
  ungroup()

spine_gp_hivposandunk_orig <- spine %>%  # grouped, HIV pos and unknown grouped together
  filter(hiv=="Positive" | is.na(hiv)) %>%
  group_by(quarter,ageg10,sex) %>%
  summarise(n=n(),.groups="keep") %>%
  mutate(hiv="posandunk") %>%
  ungroup()

spine_gp_orig <- rbind(spine_gp_all_orig, spine_gp_hivpos_orig, spine_gp_hivneg_orig,spine_gp_hivunk_orig,spine_gp_hivposandunk_orig)

both_orig <- left_join(cens_edit,spine_gp_orig) %>%  # add census denomiators
    mutate(n = case_when(is.na(n) ~ 0L,
                       TRUE ~ n)) %>%
  mutate(inc = (n/pop) * 100000) %>%
  ungroup() %>%
    mutate(q = group_indices(.,quarter))



model2pred_orig <- function(df,m){
  df %>%
    data_grid(q, sex, ageg10, .model = m) %>%
    augment(m, newdata = ., type.predict="link", se_fit=TRUE) %>%
    mutate(n_est = exp(.fitted)) %>%
    mutate(n_low =exp(.fitted - 1.96*.se.fit)) %>%
    mutate(n_high = exp(.fitted + 1.96*.se.fit))%>%
     left_join(df) %>%
  mutate(inc=exp((.fitted - log(pop)) + log(100000))) %>% #incidence per 100,000
  mutate(inc_low=exp(((.fitted - 1.96*.se.fit) - log(pop)) + log(100000))) %>% 
  mutate(inc_high=exp(((.fitted + 1.96*.se.fit) - log(pop)) + log(100000))) %>%
    ungroup()
}


```

And now run for non-imputed datasets


``` {r}
both_orig_hivpos <- both_orig %>% filter(hiv=="pos")
pos_only <- glm.nb(n ~ ns(q, knots=3)*sex*ageg10, offset(log(pop)), data=both_orig_hivpos)
out_pos <- model2pred_orig(both_orig_hivpos,pos_only)

# run function once to check - these should be fairly similar
avert_all_data(avert_est(out_pos),"Unknowns_neg") #df of output of point estimates
boot_fx(out_pos) # matrix of one boot rep of estimates

# now run function 1000 times and plot
boot_pos <- boot(out_pos,boot_fx,R=1000,sim="parametric") #1000 iterations (takes about 90 secs to run)
sd_pos <- c(sd(boot_pos$t[,1]),sd(boot_pos$t[,2]),sd(boot_pos$t[,3]),sd(boot_pos$t[,4]))
sd_pos[[1]]

hist(boot_n3$t[,1]) # check histogram output
hist(boot_n3$t[,2])
hist(boot_n3$t[,3])
hist(boot_n3$t[,4])

## Make into a table
na_neg <- avert_table(out_pos,sd_pos,"Unknowns_neg")

```

```{r}
both_orig_hivposunk <-  both_orig %>% filter(hiv=="posandunk")
posandunk <- glm.nb(n ~ ns(q, knots=3)*sex*ageg10, offset(log(pop)), data=both_orig_hivposunk)
out_unk <- model2pred_orig(both_orig_hivposunk,posandunk)

# run function once to check - point estimates and bootstrap est (1 rep) should be fairly similar
avert_all_data(avert_est(out_unk),"Unknowns_pos") #df of output of point estimates
boot_fx(out_unk) # matrix of one boot rep of estimates

# now run function 1000 times and plot
boot_unk <- boot(out_unk,boot_fx,R=1000,sim="parametric") #1000 iterations (takes about 90 secs to run)
sd_unk <- c(sd(boot_unk$t[,1]),sd(boot_unk$t[,2]),sd(boot_unk$t[,3]),sd(boot_unk$t[,4]))
sd_pos[[1]]

hist(boot_unk$t[,1]) # check histogram output
hist(boot_unk$t[,2])
hist(boot_unk$t[,3])
hist(boot_unk$t[,4])

## Make into a table
na_pos <- avert_table(out_unk,sd_unk,"Unknowns_pos")
```

Construct table 2

```{r}
imp %>% rbind(na_pos) %>% rbind(na_neg) %>% dplyr::select(NA_handling, worst_, actual_, averted_, avertedp_) %>% gt()
```
We can sense check these with the actual 'actual' numbers (not model estimates) for where we make assumptions about NAs.  Also confirms that model fits reasonably well if model predicted numbers v. close to actual numbers (neg binomial, 3 splines)

```{r}
spine %>% filter(hiv=="Positive") %>% nrow() 
spine %>% filter(hiv=="Positive" | is.na(hiv)==TRUE) %>% nrow()
```

## 9. Is the rate of change different by age and sex?

Estimate marginal trends
https://stats.idre.ucla.edu/r/seminars/interactions-r/

```{r}
## Model with imputation
int_df2 <- model_imp_n3 %>%
  ungroup() %>%
  filter(.imp == 12) %>%
  dplyr::select(model,data) # not sure why I can't just unnest....
n3_model <- int_df2[[1]][[1]]

n3_model

emtrends(n3_model, pairwise ~ ageg10|sex, var="q", data=int_df2[[2]][[1]], transform="response")
# reduction in admissions for every age and sex category (emtrends).

# Model where all HIV NA are treated as if HIV negative
emtrends(pos_only, pairwise ~ ageg10|sex, var="q", transform="response")

# Model where all HIV NA are treated as if HIV positive
emtrends(posandunk, pairwise ~ ageg10|sex, var="q", transform="response")
```

## 10. Admissions "averted" by age and sex


```{r}
boot_n3_agesex <- boot(out_n3, boot_fx_byageandsex, R=1000, sim="parametric")
# get standard deviations

sd_out_n3_agesex <- boot_n3_agesex$t %>%
  as_tibble() %>%
  summarise_all(., sd)

sd_n3 <- as.data.frame(
  matrix(sd_out_n3_agesex, nrow=12, ncol=4, byrow=FALSE)) %>% 
  rename(c("sd_worst_est"="V1", "sd_actual_est"="V2", "sd_averted_est"="V3", "sd_averted_perc"="V4")) %>%
  cbind(group_vars(out_n3)) %>% unnest(cols = c(sd_worst_est, sd_actual_est, sd_averted_est, sd_averted_perc))

boot_outpos_agesex <- boot(out_pos, boot_fx_byageandsex, R=1000, sim="parametric")
sd_outpos_agesex <- boot_outpos_agesex$t %>% as_tibble() %>% summarise_all(., sd)
   
sd_pos <- as.data.frame(
  matrix(sd_outpos_agesex, nrow=12, ncol=4, byrow=FALSE)) %>% 
  rename(c("sd_worst_est"="V1", "sd_actual_est"="V2", "sd_averted_est"="V3","sd_averted_perc"="V4")) %>%
  cbind(group_vars(out_pos)) %>% unnest(cols = c(sd_worst_est, sd_actual_est, sd_averted_est, sd_averted_perc))

boot_outunk_agesex <- boot(out_unk, boot_fx_byageandsex, R=1000, sim="parametric")
sd_outunk_agesex <- boot_outunk_agesex$t %>% as_tibble() %>% summarise_all(., sd)

sd_unk <- as.data.frame(
  matrix(sd_outunk_agesex, nrow=12, ncol=4, byrow=FALSE)) %>% 
  rename(c("sd_worst_est"="V1", "sd_actual_est"="V2", "sd_averted_est"="V3","sd_averted_perc"="V4")) %>%
  cbind(group_vars(out_unk)) %>% unnest(cols = c(sd_worst_est, sd_actual_est, sd_averted_est, sd_averted_perc))

n3_ageandsex <- avert_est(out_n3) %>% group_by(ageg10,sex) %>% summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>% mutate(avert_p_est=avert_est / worst_est) %>% left_join(sd_n3) %>% ungroup()
pos_ageandsex <- avert_est(out_pos) %>% group_by(ageg10,sex) %>% summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>% mutate(avert_p_est=avert_est / worst_est) %>% left_join(sd_pos) %>% ungroup()
unk_ageandsex <- avert_est(out_unk) %>% group_by(ageg10,sex) %>% summarise_at(vars(worst_est,actual_est,avert_est),funs(sum)) %>% mutate(avert_p_est=avert_est / worst_est) %>%left_join(sd_unk) %>% ungroup()


a <- pos_ageandsex %>% left_join(unk_ageandsex, by=c("ageg10", "sex"), suffix=c(".pos", ".unk"))
b <- n3_ageandsex %>% left_join(a, by=c("ageg10","sex"), suffix=c(".imp",".cc"))

tab_3 <- b %>% dplyr::select(c(ageg10, sex, starts_with("avert"), starts_with("sd_avert"))) %>%
  mutate(imp = paste0(
    round(avert_est,digits=0)," (",round(avert_est - 1.96*(sd_averted_est),digits=0)," to ",round((avert_est + 1.96*(sd_averted_est)),digits=0),")"
    )) %>%
  mutate(imp_p = paste0(
    round(avert_p_est,digits=3)," (",round(avert_p_est - 1.96*(sd_averted_perc),digits=3)," to ",round((avert_p_est + 1.96*(sd_averted_perc)),digits=3),")"
    )) %>%
    mutate(unk_neg = paste0(
    round(avert_est.pos,digits=0)," (",round(avert_est.pos - 1.96*(sd_averted_est.pos),digits=0)," to ",round((avert_est.pos + 1.96*(sd_averted_est.pos)),digits=0),")"
    )) %>%
    mutate(unk_neg_p = paste0(
    round(avert_p_est.pos,digits=3)," (",round(avert_p_est.pos - 1.96*(sd_averted_perc.pos),digits=3)," to ",round((avert_p_est.pos + 1.96*(sd_averted_perc.pos)),digits=3),")"
    )) %>%
    mutate(unk_pos = paste0(
    round(avert_est.unk,digits=0)," (",round(avert_est.unk - 1.96*(sd_averted_est.unk),digits=0)," to ",round((avert_est.unk + 1.96*(sd_averted_est.unk)),digits=0),")"
    )) %>%
    mutate(unk_pos_p = paste0(
    round(avert_p_est.unk,digits=3)," (",round(avert_p_est.unk - 1.96*(sd_averted_perc.unk),digits=3)," to ",round((avert_p_est.unk + 1.96*(sd_averted_perc.unk)),digits=3),")"
    )) %>%
  dplyr::select(ageg10,sex,imp,unk_neg,unk_pos,imp_p,unk_neg_p,unk_pos_p)

# Table 3
tab_3 %>% dplyr::select(ageg10,sex,imp, imp_p, unk_neg, unk_neg_p, unk_pos, unk_pos_p) %>%
  gt() %>%
  tab_spanner(
    label="HIV status imputed when missing",
    columns=vars(imp, imp_p)
  ) %>%
    tab_spanner(
    label="HIV unknowns assumed negative",
    columns=vars(unk_neg, unk_neg_p)
  ) %>%
    tab_spanner(
    label="HIV unknowns assumed positive",
    columns=vars(unk_pos, unk_pos_p)
  ) %>%
  cols_label(ageg10 = "Age group",
             sex="Sex",
             imp="Absolute number",
             imp_p="Relative decline",
             unk_neg="Absolute number",
             unk_neg_p="Relative decline",
             unk_pos="Absolute number",
             unk_pos_p="Relative decline")
```

## 11. Secondary objective -- outcome (dead or alive) Table of outcomes

Original (non-imputed data)
```{r}
a <- spine %>%
  mutate(hivart=case_when(
    hiv=="Positive" & art=="yes_art" ~ "HIV positive, on ART",
    hiv=="Positive" & art=="no_art" ~ "HIV positive, not on ART",
    hiv=="Positive" & is.na(art) ~ "HIV positive, ART status unknown",
    hiv=="Negative" ~ "HIV negative",
    is.na(hiv)==TRUE ~ "HIV status unknown"
  ))  %>%
  tabyl(hivart, outcome) 
tab_3a <- a %>% adorn_percentages() %>% adorn_pct_formatting(digits=1) %>% left_join(a, by="hivart", suffix=c("perc","n"))
tab_3a
```

Following imputation - mean of all 25 imputations

```{r}
# Table 3, second part
b1 <- spine_imp %>%
  group_by(hiv, .imp, outcome) %>% summarise(n=n()) %>% group_by(hiv, outcome) %>%
  summarise(n=round(mean(n),digits=0)) %>% 
  pivot_wider(names_from=outcome, values_from=n) %>%
  mutate(total=`0` + `1`)

tab_3b <- b1 %>% adorn_percentages() %>% adorn_pct_formatting(digits=1) %>% left_join(b1, by="hiv", suffix=c("perc","n"))
tab_3b %>% gt()
```

And the ART bit in table 3

```{r}
# spine_imp2 already created - a reminder of what it is...
#spine_imp2 <- mice::complete(spine_mice, action="long", include = TRUE)
#spine_imp2$hiv_recorded <- cci(spine$hiv)  # cci = complete case indicator in mice

spine_imp4 <- spine_imp2 %>% filter(.imp!=0) # get rid of original data
b2 <- spine_imp4 %>%
    mutate(hivart=case_when(
    hiv=="Positive" & art=="yes_art" ~ "HIV positive, on ART",
    hiv=="Positive" & art=="no_art" ~ "HIV positive, not on ART",
    hiv=="Negative" ~ "HIV negative",
    hiv_recorded==FALSE & hiv=="Positive" ~ "HIV pos imputed, likely no ART",
  ))  %>%
  group_by(hivart, .imp, outcome) %>% summarise(n=n(), .groups="keep") %>% 
  group_by(hivart, outcome) %>% summarise(n=round(mean(n),digits=0)) %>% 
  pivot_wider(names_from=outcome, values_from=n) %>%
  mutate(total=`0` + `1`)

tab_3c <- b2 %>% adorn_percentages() %>% adorn_pct_formatting(digits=1) %>% left_join(b2, by="hivart", suffix=c("perc","n"))
tab_3c %>% gt()
```

Lastly, looking at ART coverage over time (in text, not a table)

```{r}
## % ART use over time (not for table, but in text)
b3 <- spine_imp4 %>%
    mutate(hivart=case_when(
    hiv=="Positive" & art=="yes_art" ~ "pos_onart",
    hiv=="Positive" & art=="no_art" ~ "pos_notonart",
    hiv=="Negative" ~ "neg",
    hiv_recorded==FALSE & hiv=="Positive" ~ "posimputed",
  ))  %>%
  group_by(hivart, .imp, quarter) %>% summarise(n=n(), .groups="keep") %>% 
  group_by(hivart, quarter) %>% summarise(n=round(mean(n),digits=0), .groups="keep") %>% 
  pivot_wider(names_from=hivart, values_from=n) %>%
  mutate(p_ofknownhiv=pos_onart / (pos_onart + pos_notonart)) %>%
  mutate(p_ofallhiv=pos_onart / (pos_onart + pos_notonart + posimputed))
b3
```


## 12. Secondary objective -- outcome (dead or alive) over time

Only looking within PLHIV group.  

```{r}
spine_outcome_pos <- spine_imp %>%
  mutate(art=as.character(art)) %>%
  mutate(art=if_else(is.na(art)==TRUE,"no_art",art)) %>%  # add this bit here to make art "NAs" into no_art
  mutate(art=as.factor(art)) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter)) %>%
  filter(hiv=="Positive") %>% # filter for HIV
  nest_by(.imp)

spine_outcome_neg <- spine_imp %>%
  mutate(art=as.character(art)) %>%
  mutate(art=if_else(is.na(art)==TRUE,"no_art",art)) %>%  # add this bit here to make art "NAs" into no_art
  mutate(art=as.factor(art)) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter)) %>%
  filter(hiv=="Negative") %>% # filter for HIV
  nest_by(.imp)

spine_outcome_gp <- spine_imp %>%
  filter(hiv=="Positive") %>% # filter for HIV
  mutate(art=as.character(art)) %>%
  mutate(art=if_else(is.na(art)==TRUE,"no_art",art)) %>%  # add this bit here to make art "NAs" into no_art
  mutate(art=as.factor(art)) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter)) %>%
  mutate(ageg10 = as.factor(ageg10)) %>%
  mutate(q = group_indices(.,quarter)) %>%
  group_by(.imp, q, quarter, ageg10, sex, hiv) %>%  # NB. art statuds (deliberately) not here
  summarise(n_died= sum(outcome==1), n_alive=sum(outcome==0),n_all=n()) %>%
  mutate(odds_death = n_died/n_alive) %>%  # adding in outcome data I need
  mutate(risk_death = n_died/n_all) %>%
  ungroup() %>%
  nest_by(.imp)

model2pred_outcome_imp <- function(df,m){
  
  scaffold_df <- 
  {if (".imp" %in% names(df)==TRUE) df %>% filter(.imp==1) %>% dplyr::select(-.imp) else df} %>% # as before this 'if' statement so that function works for imputed datasets or original [and - also as before - model outouts are exactly the same in each imputed dataset as they are melding across]
  filter(hiv=="Positive") %>% #NB. keeping HIV pos only
  ungroup() %>%
   mutate(q = group_indices(.,quarter)) %>%
  expand(q, ageg10, sex) 
  
  quarter <- spine_imp %>% filter(.imp==1,hiv=="Positive") %>%  mutate(q = group_indices(.,quarter)) %>% dplyr::select(q,quarter)
  
  predict_melded <- tibble(models = m$model) %>%
  ungroup() %>%
  mutate(m = 1:n(),
         fitted = models %>% map(~ augment(., newdata = scaffold_df, se_fit=TRUE))) %>% # this gives fit from each model (I think)
  unnest(fitted) %>%
  dplyr::select(m,q,sex,ageg10,.fitted,.se.fit) %>% # added in select to get rid of model df that was slowwing everything down....
  group_by(q, ageg10, sex) %>%  # Group by each of the variables that you vary
  nest(data= c(m, .fitted, .se.fit))  %>% # need to add 'm' here, otherwise nothing to meld over
  mutate(fitted_melded = data %>% map(~ meld_predictions(.))) %>% 
  unnest(fitted_melded) %>% 
  mutate(rmin = .fitted - (1.96 * .se.fit), 
         rmax = .fitted + (1.96 * .se.fit))
  
response_scale <- predict_melded %>%
  mutate(chance_death = exp(.fitted),
         conf.low=exp(rmin),
         conf.high=exp(rmax)) %>%
  right_join(quarter)
response_scale
}

model2pred_outcome_orig <- function(df,m){
df %>%
    data_grid(q, sex, ageg10, .model = m) %>%
    augment(m, newdata = ., type.predict="link", se_fit=TRUE) %>%
    mutate(rmin = .fitted - (1.96 * .se.fit), 
         rmax = .fitted + (1.96 * .se.fit)) %>%
    left_join(df) %>%
      mutate(chance_death = exp(.fitted),
             conf.low=exp(rmin),
             conf.high=exp(rmax))
}

```

And the model (no ART included)

``` {r}
death_risk_pos <- spine_outcome_pos %>% mutate(model = list(glm(outcome ~ q*ageg10*sex, data = data,family=binomial(link="log")))) #log binomial to approximate risk rather than odds
death_out_risk_pos <- model2pred_outcome_imp(spine_imp,death_risk_pos)

death_risk_neg <- spine_outcome_neg %>% mutate(model = list(glm(outcome ~ q*ageg10*sex, data = data,family=binomial(link="log")))) #log binomial to approximate risk rather than odds
death_out_risk_neg <- model2pred_outcome_imp(spine_imp,death_risk_neg)

label_sum <- spine_imp %>%
  filter(.imp==2, hiv=="Positive") %>%
  group_by(ageg10, sex) %>%
  summarise(sum = sum(n()), .groups="keep")

ggplot() +
  geom_line(data=death_out_risk_pos, aes(x = quarter, y = chance_death),color="#0066CC") +
  geom_ribbon(data=death_out_risk_pos, aes(x=quarter, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill="#1AB8FF") +
  facet_grid(sex ~ ageg10) +
  geom_point(data=spine_outcome_gp %>% unnest(data) %>% filter(.imp==12), aes(x=quarter, y=risk_death),size=0.3) +
  #geom_text(data=label_sum, aes(x=ymd("2014-10-01"), y=0.7, label=paste0("n=",sum, sep="")), color="blue") +
  labs(title = "Risk of death if HIV positive and admitted to hospital",
         caption = "HIV status and outcome imputed where missing")+
  ylab("Risk of death (%)") +
  xlab("Year and quarter") +
  scale_x_date(breaks=breaks1, date_labels = "%b%y ") +
  coord_cartesian(ylim = c(0,0.6)) +
    theme_bw() %+replace%
  theme(panel.spacing = unit(1, "lines"),
        axis.text.x=element_text(angle = 90))

ggsave(here("figures/fig_3.pdf"), width = 9, height = 6, dpi=300)

## What is trend line??
int_df2 <- death_risk_pos %>%
  ungroup() %>%
  filter(.imp == 12) %>% # NB. This is only one (of 25) models
  dplyr::select(model,data)
outcome_model <- int_df2[[1]][[1]]

x <- tidy(outcome_model, conf.int=TRUE)

emtrends(outcome_model, pairwise ~ ageg10|sex, var="q", data=int_df2[[2]][[1]], transform="response")
# reduction in admissions for every age and sex category (emtrends).
```

## 13. Sensitivity analysis (just those with known HIV)

```{r}
spine_gp_hivpos_orig <- spine %>% 
 filter(hiv=="Positive") %>% # filter for HIV
  filter(is.na(outcome)==FALSE) %>% #filter out those with no outcome
  mutate(art=as.character(art)) %>%
  mutate(art=if_else(is.na(art)==TRUE,"no_art",art)) %>%  # add this bit here to make art "NAs" into no_art
  mutate(art=as.factor(art)) %>%
  ungroup() %>%
  mutate(q = group_indices(.,quarter)) %>%
  mutate(ageg10 = as.factor(ageg10)) %>%
  mutate(q = group_indices(.,quarter)) %>%
  group_by(q, quarter, ageg10, sex, hiv) %>% # NB. art statuds (deliberately) not here
  summarise(n_died= sum(outcome==1), n_alive=sum(outcome==0),n_all=n()) %>%
  mutate(odds_death = n_died/n_alive) %>%  # adding in outcome data I need
  mutate(risk_death = n_died/n_all)

b <- spine %>% filter(hiv=="Positive") %>%   mutate(q = group_indices(.,quarter))
death_risk_orig_pos <-glm(outcome ~ q*ageg10*sex,family=binomial(link="log"), data=b)
death_out_risk_pos <- model2pred_outcome_orig(b,death_risk_orig_pos)  

ggplot() +
  geom_line(data=death_out_risk_pos, aes(x = quarter, y = chance_death),color="#7F00FF") +
  geom_ribbon(data=death_out_risk_pos, aes(x=quarter, ymin = conf.low, ymax = conf.high), alpha = 0.2, fill="#7F00FF") +
  facet_grid(sex ~ ageg10) +
  geom_point(data=spine_gp_hivpos_orig, aes(x=quarter, y=risk_death),size=0.3) +
  #geom_text(data=label_sum, aes(x=ymd("2014-10-01"), y=0.7, label=paste0("n=",sum, sep="")), color="blue") +
  labs(title = "Risk of death if HIV positive and admitted to hospital (complete case)",
       caption = "Excluding those with missing HIV status, and those without outcome recorded")+
  ylab("Risk of death (%)") +
  xlab("Year and quarter") +
  scale_x_date(breaks=breaks1, date_labels = "%b%y ") +
    theme_bw() %+replace%
  theme(panel.spacing.x=unit(0.5, "cm"),
        axis.text.x=element_text(angle = 90))

```


## 12. Does ART make any difference to these preductions?

```{r}
death_risk_pos_art <- spine_outcome_pos %>% mutate(model = list(glm(outcome ~ q*ageg10*sex*art, data = data,family=binomial(link="log")))) # add ART to illustrate / model (even though doesn't improve fit by AIC)

death_risk_pos <- spine_outcome_pos %>% mutate(model = list(glm(outcome ~ q*ageg10*sex, data = data,family=binomial(link="log")))) #log binomial to approximate risk rather than odds

model2pred_outcome_imp2 <- function(df,m){  ## This adds ART
  
  scaffold_df <- 
  {if (".imp" %in% names(df)==TRUE) df %>% filter(.imp==1) %>% dplyr::select(-.imp) else df} %>%
  filter(hiv=="Positive") %>% #NB. keeping HIV pos only
  ungroup() %>%
   mutate(q = group_indices(.,quarter)) %>%
  expand(q, ageg10, sex,art)  ## add in ART here
  
  quarter <- spine_imp %>% filter(.imp==1,hiv=="Positive") %>%  mutate(q = group_indices(.,quarter)) %>% dplyr::select(q,quarter)
  
  predict_melded <- tibble(models = m$model) %>%
  ungroup() %>%
  mutate(m = 1:n(),
         fitted = models %>% map(~ augment(., newdata = scaffold_df, se_fit=TRUE))) %>% # this gives fit from each model (I think)
  unnest(fitted) %>%
  dplyr::select(m,q,sex,ageg10,art,.fitted,.se.fit) %>% # added in select to get rid of model df that was slowwing everything down....
  group_by(q, ageg10, sex) %>%  # Group by each of the variables that you vary
  nest(data= c(m, .fitted, .se.fit))  %>% # need to add 'm' here, otherwise nothing to meld over
  mutate(fitted_melded = data %>% map(~ meld_predictions(.))) %>% 
  unnest(fitted_melded) %>% 
  mutate(rmin = .fitted - (1.96 * .se.fit), 
         rmax = .fitted + (1.96 * .se.fit))
  
response_scale <- predict_melded %>%
  mutate(chance_death = exp(.fitted),
         conf.low=exp(rmin),
         conf.high=exp(rmax)) %>%
  right_join(quarter)
response_scale
}

death_out_risk_pos_art <- model2pred_outcome_imp2(spine_imp,death_risk_pos_art)

models_art <- death_risk_pos_art %>% dplyr::select(model) %>% mutate(glanced=list(glance(model))) %>% unnest(glanced) 
models_no_art <- death_risk_pos %>% dplyr::select(model) %>% mutate(glanced=list(glance(model))) %>% unnest(glanced) 

models_no_art[["AIC"]] - models_art[["AIC"]]
# In every instance, models with no ART had lower AIC than models with ART included

ggplot() +
  geom_line(data=death_out_risk_pos_art%>%filter(art=="no_art"), aes(x = q, y = chance_death, color=art)) +
  geom_line(data=death_out_risk_pos_art%>%filter(art=="yes_art"), aes(x = q, y = chance_death, color=art)) +
  geom_ribbon(data=death_out_risk_pos_art%>%filter(art=="no_art"), aes(x = q, ymax = conf.high, ymin=conf.low, fill=art),alpha=0.3) +
  geom_ribbon(data=death_out_risk_pos_art%>%filter(art=="yes_art"), aes(x = q, ymax = conf.high,ymin=conf.low, fill=art),alpha=0.3) +
  facet_grid(sex ~ ageg10) +
  #geom_point(data=outcome_death %>% filter(hiv=="Positive",art=="yes_art"), aes(x=q, y=risk_death,color=art),size=0.3) +
    #geom_point(data=outcome_death %>% filter(hiv=="Positive",art=="no_art"), aes(x=q, y=risk_death,color=art),size=0.3) +
    #geom_text(data=n_no_art, aes(x=12, y=0.97, 
                #label=paste0("no art=",n, sep=""))) +
      #geom_text(data=n_yes_art, aes(x=12, y=0.80, 
                #label=paste0("yes art=",n, sep=""))) +
  ylab("Risk of death (%)") +
  xlab("Year and quarter") +
  labs(title = "Risk of death if HIV pos and admitted to hospital (by ART status") +
  theme_bw()
```
